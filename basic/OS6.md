### 《操作系统》 课程作业6

#### 姓名：<u>王炜致</u> 班级：<u>无22</u> 学号：<u>2022010542</u>

1. **对于下述十进制虚拟地址，分别使用4KB页面和8KB页面计算虚拟页号和页内偏移.**
<font color=Blue> 虚拟页号$P=\lfloor A/L\rfloor$，页内地址$d=A\ \text{mod}\ L$，其中$A$是虚拟地址，$L$是页面大小，为2的幂次.</font>

   - **20000** <font color=Blue> 
4KB页面：虚拟页号为$P=4$，页内偏移$d=3616$;
8KB页面：虚拟页号为$P=2$，页内偏移$d=3616$;
</font>

   - **32768** <font color=Blue> 
4KB页面：虚拟页号为$P=8$，页内偏移$d=0$;
8KB页面：虚拟页号为$P=4$，页内偏移$d=0$;</font>

   - **60000** <font color=Blue> 
4KB页面：虚拟页号为$P=14$，页内偏移$d=2656$;
8KB页面：虚拟页号为$P=7$，页内偏移$d=2656$;</font>

2. **某计算机采用页式内存管理，页面大小为1KB，某进程有6个逻辑页，页表内容如下图所示，试计算逻辑地址5499和3746对应的物理地址.**
![alt text](image-5.png)
   - **5499** <font color=Blue> 
虚拟页号为$P=5$，页内偏移$d=379$;则物理页号为0，偏移为379，物理地址为379；
</font>

   - **3746** <font color=Blue> 
虚拟页号为$P=3$，页内偏移$d=674$;则物理页号为2，偏移为674，物理地址为2722.
</font>

1. **某进程页面访问序列为：2，3，2，1，5，2，4，5，3，2，5，2，假设系统分配给该进程的页框数为3，针对下述页面置换算法计算缺页率.**
<font color=Blue>在程序执行过程中，如果需执行的指令或访问的数据尚未在内存(称为缺页中断)，则由处理器通知操作系统执行缺页中断处理程序，将相应的页调入到内存，然后继续执行程序.</font>

   - **OPT算法**
   <font color=Blue> 初始为空；访问2，缺页，调入2；访问3，缺页，调入3；访问2，**不缺页**；访问1，缺页，调入1；访问5，缺页，页框满，OPT算法将调出1（未来不再使用），调入5；访问2，**不缺页**；访问4，缺页，页框满，OPT算法将调出2（离当前最远时间才使用的页面），调入4；访问5，**不缺页**；访问3，**不缺页**；访问2，缺页，页框满，OPT算法将调出3或4（未来不再使用），调入2；访问5，**不缺页**；访问2，**不缺页**.因此缺页率为$6/12=50\%$.
   </font>
   - **FIFO算法**
   <font color=Blue> 初始为空；访问2，缺页，调入2；访问3，缺页，调入3；访问2，**不缺页**；访问1，缺页，调入1；访问5，缺页，页框满，FIFO算法将调出2（最老的页面），调入5；访问2，缺页，页框满，FIFO算法将调出3（最老的页面），调入2；访问4，缺页，页框满，FIFO算法将调出1（最老的页面），调入4；访问5，**不缺页**；访问3，缺页，页框满，FIFO算法将调出5（最老的页面），调入3；访问2，**不缺页**；访问5，缺页，页框满，FIFO算法将调出2（最老的页面），调入5；访问2，缺页，页框满，FIFO算法将调出4，调入2.因此缺页率为$9/12=75\%$.
   </font>
   - **CLOCK算法（页面编号：访问位）** 检查**最老页面**的R位，如果为0，则置换掉；如果为1，则清除该位，并将该页放到链表的末尾.链表从左到右表示装入时间先后，新加入页面永远放在链表最右，且1置0的页面会被视为新加入页面，不缺页则原地置1即可
   <font color=Blue> 初始为空；访问2，[2:0,-,-]，缺页；访问3，[2:0,3:0,-]，缺页；访问2，[2:1,3:0,-]，**不缺页**；访问1，[2:1,3:0,1:0]，缺页；访问5，[1:0,2:0,5:0]，缺页；访问2，[1:0,2:1,5:0]，**不缺页**；访问4，[2:1,5:0,4:0]，缺页；访问5，[2:1,5:1,4:0]，**不缺页**；访问3，[2:0,5:0,3:0]，缺页；访问2，[2:1,5:0,3:0]，**不缺页**；访问5，[2:0,5:1,3:0]，**不缺页**；访问2，[2:1,5:1,3:0]，**不缺页**.因此缺页率为$6/12=50\%$.
   </font>
   - **LRU算法**
   <font color=Blue> 初始为空；访问2，缺页，调入2；访问3，缺页，调入3；访问2，**不缺页**；访问1，缺页，调入1；访问5，缺页，页框满，LRU将调出3（最久未使用的页面），调入5；访问2，**不缺页**；访问4，缺页，页框满，LRU将调出1，调入4；访问5，**不缺页**；访问3，缺页，页框满，LRU将调出2，调入3；访问2，缺页，页框满，LRU将调出4，调入2；访问5，**不缺页**；访问2，**不缺页**.因此缺页率为$7/12\approx58\%$.
   </font>

4.**某计算机采用虚拟页式内存管理。现有如下两个程序片段A和B，其功能是对256*256的整型数组进行初始化。假设页面大小为2KB，且程序执行时系统只分配了1个页框，试计算执行程序片段A和B的缺页次数。整型变量占4个字节（32位）.**

- **程序A**
```c
int a[256][256];
int i,j;
for(i=0;i<256;i++)
   for(j=0;j<256;j++)
      a[i][j]=0;
```
   <font color=Blue> 数组a每行占用1KB内存，故单页面可以容纳2行，a一共占用128个页面；**行**优先遍历数组，a的每个页面在访问时均会发生缺页，故缺页次数为128.
   </font>
   
- **程序B**
```c
int a[256][256];
int i,j;
for(j=0;j<256;j++)
   for(i=0;i<256;i++)
      a[i][j]=0;
```
   <font color=Blue> 数组a每行占用1KB内存，故单页面可以容纳2行，a一共占用128个页面；**列**优先遍历数组，因为访问顺序严重背离空间相邻原则，a每2个元素在访问时就会发生缺页，故缺页次数为256*256/2即32768.
   </font>

5.**考虑下面的C程序：**
```c
int X[N];
int step=M; //M is some predefined constant
for(int i=0;i<N;i+=step)
   X[i]=X[i]+1;
```
**整型变量占4个字节（32位）.**

   - **如果该程序运行在页面大小4KB且具有64个TLB表项的机器上，M和N
取什么值将使得循环的每次执行都会导致TLB缺失？**
   <font color=Blue> TLB实际上对应了实际页面.要使每次访问 X[i] 都触发TLB缺失，每次访问的 X[i] 应当位于不同的虚拟页；由于整型变量占4B，即有$M\times4\ge4096$，$M\ge1024$.
   </font>
   - **如果循环重复很多次，答案如何？**
   <font color=Blue> 若循环重复很多次（仍然每次执行都会导致TLB缺失），说明数组X所占页数超过了64个TLB，故保持$M\ge1024$，提出新约束$N>1024\times64=65536$.
   </font>